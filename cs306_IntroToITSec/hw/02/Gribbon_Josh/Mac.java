//package stevens.cs306.mac;

import java.security.Key;
import javax.xml.bind.DatatypeConverter;
import java.util.Arrays;

// Implement this class
public class Mac extends MacSkeleton {

    /**
     * Implement the mac and verify methods.  Mac should take a message and a
     * key (generated by the generate method) and return a tag.  Verify should
     * take a message, tag, and key -- and authenticate that the tag corresponds
     * to the message/tag pair by returning true or false.
     *
     * The following methods have been made available to you through the
     * MacSkeleton class:
     *
     * byte[] xor(byte[] a, byte[] b) :: XOR two byte arrays. Returns result
     * byte[] pad(byte[] message, int blockSz) :: pads message to blockSz
     * byte[] encryptBlock(byte[] block, Key key) :: Encrypts a single block
     * int getBlockSize() :: Returns the block size of the cipher
     */

    /**
     * Creates a message authentication tag for a message with a given key.
     * @param message   The message to generate a MAC for
     * @param key       A secret key to use for MAC'ing the message
     * @return          A valid tag for the message
     */
    public byte[] mac(byte[] message, Key key) {
        // Figure out how long the padded message needs to be before it gets
        // split into blocks
        int block_size = getBlockSize();
        int modulo_diff = message.length % block_size;
        int pad_size = modulo_diff==0
                        ? message.length
                        : message.length - modulo_diff + block_size;
        if(pad_size%block_size != 0){
            throw new Error(
                "\nError: Padded message size is not an even multiple of the block size.\n"+
                    "\tMessage length: " + message.length + "\n" +
                    "\tBlock   length: " + block_size + "\n" +
                    "\tPadded  length: " + pad_size);
        }

        // Pad the message
        byte [] padded_msg = new byte[pad_size];
        if(modulo_diff != 0){
            padded_msg = pad(message, pad_size);
        }else{
            padded_msg = message;
        }

        // Iterate to get blocks and create tag
        byte[] tag = new byte[block_size];
        byte[] iter_block = new byte[block_size];
        int start_i = 0;
        int end_i = start_i + block_size;

        for(int i=0; i<(pad_size/block_size); i++){
            //get the part of the message to use for this iteration
            start_i = block_size * i;
            end_i = start_i + block_size;
            System.arraycopy(padded_msg, start_i, iter_block, 0, block_size);

            // if there's a previous tag then xor with that first
            if(start_i!=0){
                iter_block = xor(iter_block, tag);
            }
            // do the encryption to create the new tag
            try{
                tag = encryptBlock(iter_block, key);
            }catch(Exception e){
                System.out.println(e.getMessage());
            }
        }
        // return the finalized tag
        return tag;
    }

    /**
     * Authenticates a message/tag pair with a key.  Returns true if the pair
     * is authentic, else false.
     * @param message   message to authenticate
     * @param tag       a MAC tag to authenticate with the message
     * @param key       secret key to authenticate the tag with
     */
    public boolean verify(byte[] message, byte[] tag, Key key) {
        // Get the correct mac
        byte[] mac = mac(message, key);
        // Return true if it's equal to the submitted mac tag
        return Arrays.equals(mac, tag);
    }

    public static String toHexString(byte[] array) {
        return DatatypeConverter.printHexBinary(array);
    }

    public static byte[] toByteArray(String s) {
        return DatatypeConverter.parseHexBinary(s);
    }

}
